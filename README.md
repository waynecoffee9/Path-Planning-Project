# CarND-Path-Planning-Project
Self-Driving Car Engineer Nanodegree Program
   
### Goals
The goal of this project is to safely navigate a car in a virtual highway with other traffic.  The car should try to go as close as possible to the 50 MPH speed limit.  The car should avoid hitting other cars at all cost as well as driving inside of the marked road lanes at all times, unless going from one lane to another.  The car should be able to make one complete loop around the 6946m highway. Since the car is trying to go 50 MPH, it should take a little over 5 minutes to complete 1 loop. Also the car should not experience total acceleration over 10 m/s^2 and jerk that is greater than 10 m/s^3.

## Completed Project Files

In order to organize codes, new files were created to separate functions and classes from the main.cpp.
New files: vehicle.h, vehicle.cpp, cost.h, cost.cpp, helpers.h
The CMakeLists.txt file was updated to include the files above.


## Build Instructions

1. Clone this repo.
2. Make a build directory: `mkdir build && cd build`
3. Compile: `cmake .. && make`
4. Run it: `./path_planning`.

## Model Documentation

There are several files put together for the path planning algorithm.
1. main.cpp : gathers Ego's (this car) and nearby vehicles' telemetries, and send relevant information to vehicle.cpp to determine best path forward.
2. vehicle.cpp : class object that stores vehicle telemetries and determines next state based on the information passed from main.cpp.  It also generates appropriate trajectories for Ego to follow.  Next state is chosen by calculating the lowest cost from cost.cpp.
3. cost.cpp : calculates costs for all possible next states based on current state.

To go into algorithm details, the main.cpp creates a vehicle object called Ego, and it stores current Ego's telemetries.  A map of other vehicle objects is declared to store other vehicles' telemetries.  Next, the algorithm checks if Ego is getting too close to any vehicle in front.  If it does, set a new lower velocity to follow. When a lower velocity is set, previously set path points are reduced down to a constant SHORT_PATH_PTS.  Then, base points of the path splines are setup, and function choose_next_state() is called with all the gathered information.

In choose_next_state() under vehicle.cpp, successor_states() is called to provide a list of all possible maneuver.  For each maneuver, a trajectory is generated by calling generate_trajectory(), and cost is calculated by calling calculate_cost() associated with its maneuver.

In generate_trajectory(), keep_lane_trajectory() is called if current state is KL (keep lane) or PLCL/PLCR (prepare lane change left/right), and lane_change_trajectory() is called if current state is LCL/LCR (lane change left/right).

In keep_lane_trajectory(), s spline and v spline are generated for position and velocity, respectively.  Two points from last two path points in previous cycle are included to ensure smooth transition of Ego's trajectory.  Two types of trajectories can be generated here.  One is CS (constant speed).  This is used when Ego is at max allowed speed set in the algorithm, MAX_VEL.  The other one is KL (keep lane).  This is used when a vehicle in front of Ego is traveling at a slower speed and Ego has to slow down accordingly to avoid collision, or at start up when Ego needs to increase speed to max.  The velocity spline is incorporated to lower the jerk.

In lane_change_trajectory(), constant speed is used so only position spline is declared.  Mid-point between current lane and target lane is included in the spline declaration to minimize lateral acceleration and jerk.

In calculate_cost() from cost.cpp, two constants are declared, SAFETY and EFFICIENCY.  A propsed state cost is calculated with different criteria.  For KL, the cost only considers efficiency, which has inverse relationship to the speed of the vehicle in front of Ego.  For PLCL/PLCR/LCL/LCR, both efficiency and safety are considered.  For efficiency, the algorithm looks for any other lanes (not Ego's current lane) with closest vehicles in front that is certain distance ahead of the vehicle in front of Ego.  The greater the distance, the lower the cost.  In other words, the algorithm is looking for a lane clear of vehicles for some distance to advance.  For safety, the algorithm uses distance clearance Ego and other vehicles, such as in front in the current lane, and in front / back in the target lane.  The algorithm predicts other vehicles' s positions in a few seconds based on their speeds, and uses simplified Naive Bayes method to predict if a vehicle is changing lane.  All the current and future inferred information is feeding into the safety cost calculation.

Back in choose_next_state(), the state with lowest cost is picked and its trajectory planning path points are returned to main.cpp.  These points are then implemented in the background.

## Results

To determine the path planning algorithm efficiency and distance travelled without incident, the simulation was kept on for as long as possible.  For longest distance, Ego was able to travel 206 miles before an incident occurred.  

![Best](img/best.png)

To calculate efficiency, average speed is divided by the max allowable speed x 100%.  For 104 miles travelled, the average speed was 47.1 mph.  This gives ~94% efficiency.

![Efficiency](img/best2.png)

All the observed incidents were related to other vehicles changed lane to Ego's lane in close proximity in front of Ego, which prompted Ego to decelerate over the comfort limit, or Ego changed lane behind a vehicle while the vehicle had sudden deceleration, which again prompted Ego to react to avoid collison.  None of the observed incidents were collision.

The link below captures ~11 min of video (2 laps) of path planning with my code.

<a href="img/Capture.mp4" target="_blank">Click for Video</a>

## Future Work

There is plenty of improvement to be made.  A better prediction model for other vehicles' behavior, such as EKF/UKF (Kalman Filter).  A full Naive Bayes classifier can be implemented to predict vehicle behavior in order to minimize incidents.  In addition, to increase efficiency (better path planning), Hybrid A* with other vehicle inferred future behavior can be implemented.  